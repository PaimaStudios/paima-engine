# Paima SM

Paima SM is a framework written in TS which enables building state machines for your game which natively integrate with the rest of the Paima Engine. These game state machines are effectively your "game loop" where all of your game logic is held. Unlike ordinary video game loops which typically take place in a consistent timed manner (30+ times a second), our state machines only performs state transition when a new block is produced on the blockchain that the Paima Contract is deployed on.

Paima SM natively integrates with a postgres DB as it's default storage backend for global game state.

## Chain Data

Games implemented with Paima Engine will only perform computation by going through state transitions. As mentioned, state transitions only take place when a new block occurs on the blockchain; funneled to PaimaSM through Paima Funnel by the Paima Engine Runtime. This new Chain Data is pre-processed by PaimaSM and then fed into the game's state transition function. If the blockchain block included transactions where users submitted data (potentially game input) to the Paima Contract, said data will processed one-by-one via the state transition function.

Chain Data will be formatted as such:

```json
{
  "timestamp": "ISO8601...",
  "blockHash": "912jasdfio3jfai...",
  "blockNumber": "29582384",
  "submittedData": [
    {
      "userAddress": "0x33asdfajaf8j...",
      "data": "..."
    }
  ]
}
```

## State Transition Function

To reiterate, the state transition function is the function where all game logic takes place. The developer using Paima SM must implement their own state transition function for the different mechanics and dynamics of their game.

This function is required to take the following as input:

- Input Data
- Block Number
- Randomness Seed (a random seed generated by Paima SM to be used for randomness, also saved to the DB randomness table)
- Database object (an object which can be used to access the database via a read-only interface)

The output of said function is a list of SQL update commands which should include all updates that will be applied to the global game state based on all of the results from the state transition since the previous state.

The state transition function will look as such (note this is pseudocode, including the types):

```ts
function gameStateTransition(inputData: InputData, blockNumber: number, randomSeed: number, db: Database): SQLUpdate {
  ...
  let sqlUpdate = ...;
  return sqlUpdate;
}
```

## Trigger State Transitions

Before triggering state transitions the developer must first initialize the game state machine object (which connects to the DB/acquires the DB schema, and sets which randomness protocol version to use).

From there, the Paima Engine Runtime acquires the next Chain Data (from on-chain Paima Contract via Paima Funnel) and then process all of the state transition for the latest block of Chain Data.

```ts
// Initializes the game state machine
let gameSM = paimaSM.initialize(
  databaseInfo,
  randomnessProtocolEnum,
  gameStateTransition
);


...

/// This will be inside of Paima Engine Runtime

// Acquires the latest block height of the last Chain Data which was processed by the game SM.
// Paima SM should save the latest block height it has parsed (on success of the state transition function)
// to the DB.
let latestReadBlockHeight = gameSM.latestBlockHeight();

let latestChainData = chainFunnel.readData(
  latestReadBlockHeight
);

gameSM.process(latestChainData);
```

## Internals Of Processing Chain Data

When `.process(latestChainData)` is called, PaimaSM automatically begins performing one or more state transitions via the `gameStateTransition()` function.

First PaimaSM checks the `scheduledData` table in the attached database. This is a table which stores a list of entries which have a block height (number) as their primary key, and some `inputData` as their value. In other words, these are scheduled actions which were generated by previous state transitions to take place at a given block height. Executing these first every time a new block is generated (even with no submitted data to Paima Contract) on the chain allows for Paima Engine to offer passive time to games implemented with it.

Whenever `.process(latestChainData)` is called on the game state machine, PaimaSM automatically queries for all scheduled data for the current height and begins triggering `gameStateTransition()` one-by-one. After each call, the STF will return a list of SQL update queries, which PaimaSM automatically applies to the database before calling the `gameStateTransition()` function again with the next input data. As such, each successive state transition has access to the latest global game state because all updates are commit to the database before proceeding (every time a piece of scheduled data is processed, it is also deleted from the `scheduledData` table).

Once all of the scheduled data has been processed, then PaimaSM begins to feed all of the `submittedData` from the `latestChainData` one-by-one to the `gameStateTransition()` function as well. Likewise, PaimaSM commits all SQL update queries to the database after each STF call. Note, any single given input data which was provided in `submittedData` may have been invalid. This means that `gameStateTransition()` may fail for that given piece of submitted data, in which case no updates are committed to the database and that submitted data is simply thrown away.

After all of the `submittedData` has been used one-by-one, this marks the end of processing of the Chain Data. All scheduled data and all user supplied input were processed for the given block height, and thus we have arrived at the latest state.

## Considerations

This approach allows us to easily schedule "passive time" events and mutate all global game state without any worries about state update conflicts. This implementation is very straightforward, and as such offers us the majority of benefits we are looking for without spending months of development work focused on implementing advanced parallelization/state partitioning protocols.

The two negatives of note with this approach are:

1. No parallelization, thus some performance left on the table (though not a big deal in general until we grow substantially)
2. We commit to the database after each input data is processed, rather than after all input data is processed all at once.

Negative #1 is reasonably minor based off our requirement for today. Negative #2 on the other hand is a bit more annoying, because it means that we have these "intermediary states" where users querying the database about some sub-set of global game state may happen to do so while the latest Chain Data is being processed and get a different answer than when all of the state transitions finish processing.

This is not a major problem however, as the state transition function should be designed such that every intermediary state is perfectly valid. Furthermore, using a lobby/match/room model naturally leans into this, meaning that we don't have to do any new engineering yet we still maintain state coherency.
