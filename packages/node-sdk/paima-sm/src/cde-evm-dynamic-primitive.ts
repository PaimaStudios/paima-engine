import { insertDynamicExtension, registerDynamicChainDataExtension } from '@paima/db';
import type { SQLUpdate } from '@paima/db';
import type { TChainDataExtensionErc721Config, TChainDataExtensionGenericConfig } from './types.js';
import { CdeEntryTypeName, type CdeDynamicEvmPrimitiveDatum } from './types.js';
import {
  ChainDataExtensionType,
  DYNAMIC_PRIMITIVE_NAME_SEPARATOR,
  GlobalConfig,
} from '@paima/utils';

// We omit storing the name from the config because it's dynamically generated
// on the db insert as the primary key of the row. We can then recover it from
// the row when needed.
type StoredConfig<T> = Omit<T, 'name'> & { network: string };

export default async function processDatum(
  cdeDatum: CdeDynamicEvmPrimitiveDatum,
  _inPresync: boolean
): Promise<SQLUpdate[]> {
  let type;
  let config;

  // the numeric id is generated by the insert query.
  const baseName = `${cdeDatum.cdeName}${DYNAMIC_PRIMITIVE_NAME_SEPARATOR}`;

  const networkConfig = await GlobalConfig.networkForCaip2(cdeDatum.caip2);
  if (networkConfig == null) {
    throw new Error(`No network found in config for caip2: ${cdeDatum.caip2}`);
  }
  switch (cdeDatum.payload.targetConfig.type) {
    case CdeEntryTypeName.ERC721:
      type = ChainDataExtensionType.ERC721;

      const erc721Config: StoredConfig<TChainDataExtensionErc721Config> = {
        ...cdeDatum.payload.targetConfig,
        contractAddress: cdeDatum.payload.contractAddress.toLowerCase(),
        startBlockHeight: cdeDatum.blockNumber,
        network: networkConfig[0],
      };

      config = erc721Config;
      break;

    case CdeEntryTypeName.Generic:
      type = ChainDataExtensionType.Generic;

      const genericConfig: StoredConfig<TChainDataExtensionGenericConfig> = {
        ...cdeDatum.payload.targetConfig,
        contractAddress: cdeDatum.payload.contractAddress.toLowerCase(),
        startBlockHeight: cdeDatum.blockNumber,
        network: networkConfig[0],
      };

      config = genericConfig;
      break;
    default:
      // This shouldn't really happen, but for some reason using the assertNever
      // idiom does not work.
      throw new Error('Unsupported dynamic primitive target');
  }

  const updateList: SQLUpdate[] = [
    [
      registerDynamicChainDataExtension,
      {
        base_name: baseName,
        cde_type: type,
        cde_caip2: cdeDatum.caip2,
        start_blockheight: cdeDatum.blockNumber,
        scheduled_prefix: config.scheduledPrefix,
      },
    ],
    [
      insertDynamicExtension,
      {
        base_name: baseName,
        parent_name: cdeDatum.cdeName,
        config: config,
      },
    ],
  ];

  return updateList;
}
